BEGIN;

-- === 0) Prereqs ===
CREATE EXTENSION IF NOT EXISTS pgcrypto WITH SCHEMA public;

-- === 1) (Unchanged from earlier refactor) Connector bundle table and link on implementation
-- We keep connector_bundle + implementation.connector_bundle_id as before.
CREATE TABLE IF NOT EXISTS public.connector_bundle (
    id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    bundle_name varchar(255) NOT NULL UNIQUE,
    maintainer varchar(255),
    framework varchar(64)  NOT NULL,
    license   varchar(64)  NOT NULL,
    link_on_ticketing_system text
);

ALTER TABLE public.implementation
    ADD COLUMN IF NOT EXISTS connector_bundle_id integer;

-- Seed connector_bundle from existing implementation rows
WITH src AS (
    SELECT DISTINCT
        i.connector_bundle       AS bundle_name,
        i.maintainer,
        i.framework,
        i.license,
        i.link_on_ticketing_system
    FROM public.implementation i
    WHERE i.connector_bundle IS NOT NULL
)
INSERT INTO public.connector_bundle (bundle_name, maintainer, framework, license, link_on_ticketing_system)
SELECT s.bundle_name, s.maintainer, s.framework, s.license, s.link_on_ticketing_system
FROM src s
ON CONFLICT (bundle_name) DO NOTHING;

-- Backfill implementation.connector_bundle_id
UPDATE public.implementation i
SET connector_bundle_id = cb.id
FROM public.connector_bundle cb
WHERE cb.bundle_name = i.connector_bundle
  AND (i.connector_bundle_id IS DISTINCT FROM cb.id);

-- FK from implementation → connector_bundle (idempotent)
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname = 'fk_impl_bundle_id') THEN
        ALTER TABLE ONLY public.implementation
            ADD CONSTRAINT fk_impl_bundle_id
            FOREIGN KEY (connector_bundle_id) REFERENCES public.connector_bundle(id)
            ON DELETE RESTRICT DEFERRABLE INITIALLY DEFERRED;
    END IF;
END$$;

ALTER TABLE public.implementation
    ALTER COLUMN connector_bundle_id SET NOT NULL;

-- Drop moved columns from implementation
ALTER TABLE public.implementation
    DROP COLUMN IF EXISTS connector_bundle,
    DROP COLUMN IF EXISTS maintainer,
    DROP COLUMN IF EXISTS framework,
    DROP COLUMN IF EXISTS license,
    DROP COLUMN IF EXISTS link_on_ticketing_system;

-- === 2) New table: bundle_version (NO connector_bundle_id here)
CREATE TABLE IF NOT EXISTS public.bundle_version (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    connector_version varchar(255),
    browse_link       varchar(255),
    checkout_link     varchar(255),
    download_link     varchar(255),
    connid_version    varchar(64),
    released_date     date,
    build_framework   varchar(64) NOT NULL,
    error_message     varchar(255),
    path_to_project   varchar(255),  -- NEW
    CONSTRAINT fk_bv_connid FOREIGN KEY (connid_version)
        REFERENCES public.connid_version(version)
        DEFERRABLE INITIALLY DEFERRED
);

-- Ensure implementation_version.implementation_id exists and is properly constrained
ALTER TABLE public.implementation_version
    ADD COLUMN IF NOT EXISTS implementation_id integer;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_implver_impl') THEN
        ALTER TABLE ONLY public.implementation_version
            ADD CONSTRAINT fk_implver_impl
            FOREIGN KEY (implementation_id) REFERENCES public.implementation(id)
            ON DELETE CASCADE DEFERRABLE INITIALLY DEFERRED;
    END IF;
END$$;

-- Add bundle_version_id to implementation_version (new FK target)
ALTER TABLE public.implementation_version
    ADD COLUMN IF NOT EXISTS bundle_version_id uuid;

-- === 3) Backfill bundle_version and wire FKs ===

-- Insert one bundle_version per current implementation_version row (no bundle linkage needed)
INSERT INTO public.bundle_version (
    connector_version, browse_link, checkout_link, download_link,
    connid_version, released_date, build_framework, error_message
)
SELECT
    iv.connector_version,
    iv.browse_link,
    iv.checkout_link,
    iv.download_link,
    iv.connid_version,
    iv.released_date,
    iv.build_framework,
    iv.error_message
FROM public.implementation_version iv;

-- Wire implementation_version → bundle_version via correlated match on moved fields only
UPDATE public.implementation_version iv
SET bundle_version_id = bv.id
FROM public.bundle_version bv
WHERE bv.id = (
    SELECT bv2.id
    FROM public.bundle_version bv2
    WHERE
        COALESCE(bv2.connector_version,'') = COALESCE(iv.connector_version,'') AND
        COALESCE(bv2.browse_link,'')       = COALESCE(iv.browse_link,'') AND
        COALESCE(bv2.checkout_link,'')     = COALESCE(iv.checkout_link,'') AND
        COALESCE(bv2.download_link,'')     = COALESCE(iv.download_link,'') AND
        COALESCE(bv2.connid_version,'')    = COALESCE(iv.connid_version,'') AND
        COALESCE(bv2.build_framework,'')   = COALESCE(iv.build_framework,'') AND
        bv2.released_date IS NOT DISTINCT FROM iv.released_date
    LIMIT 1
)
AND (iv.bundle_version_id IS DISTINCT FROM bv.id);

-- Enforce NOT NULL on new FK after backfill
ALTER TABLE public.implementation_version
    ALTER COLUMN bundle_version_id SET NOT NULL;

-- === 4) Clean up old FK/columns now moved into bundle_version
-- Keep fk_implver_impl (as requested); DROP only fk_implver_connid
DO $$
BEGIN
    IF EXISTS (SELECT 1 FROM pg_constraint WHERE conname='fk_implver_connid') THEN
        ALTER TABLE ONLY public.implementation_version
            DROP CONSTRAINT fk_implver_connid;
    END IF;
END$$;

ALTER TABLE public.implementation_version
    DROP COLUMN IF EXISTS connector_version,
    DROP COLUMN IF EXISTS browse_link,
    DROP COLUMN IF EXISTS checkout_link,
    DROP COLUMN IF EXISTS download_link,
    DROP COLUMN IF EXISTS connid_version,
    DROP COLUMN IF EXISTS released_date,
    DROP COLUMN IF EXISTS build_framework,
    DROP COLUMN IF EXISTS error_message;
    -- NOTE: do NOT drop implementation_id

-- === 5) Add NEW column on implementation_version ===
ALTER TABLE public.implementation_version
    ADD COLUMN IF NOT EXISTS class_name varchar(255);

-- === 6) Flush deferred constraints, then create indexes ===
SET CONSTRAINTS ALL IMMEDIATE;

-- indexes (in correct order; all columns now exist)
CREATE INDEX IF NOT EXISTS idx_impl_bundle_id     ON public.implementation (connector_bundle_id);
CREATE INDEX IF NOT EXISTS idx_implver_bundlever  ON public.implementation_version (bundle_version_id);
-- removed: idx_bundlever_bundle (no connector_bundle_id on bundle_version)
CREATE INDEX IF NOT EXISTS idx_bundlever_connid   ON public.bundle_version (connid_version);

COMMIT;
